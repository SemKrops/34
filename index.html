<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>34 Jigsaw</title>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --stroke:#ffffffcc; --muted:#9aa3b2; }
    *{ box-sizing:border-box; }
    body{
      margin:0; min-height:100vh;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 600px at 50% 30%, #1a2030 0%, var(--bg) 55%, #0b0d12 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff; overflow:hidden;
    }

    .wrap{
      width:min(94vw, 520px);
      display:flex; flex-direction:column; gap:12px;
    }

    .hud{
      display:flex; align-items:center; justify-content:space-between;
      background: color-mix(in srgb, var(--panel) 88%, transparent);
      border:1px solid #ffffff14;
      border-radius:16px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
    }
    .hud .left, .hud .right{ display:flex; gap:14px; align-items:baseline; }
    .stat{ display:flex; flex-direction:column; gap:2px; }
    .label{ font-size:12px; color:var(--muted); letter-spacing:.2px; }
    .value{ font-size:18px; font-weight:700; }

    .btn{
      appearance:none; border:1px solid #ffffff20; color:#fff;
      background:#ffffff10; border-radius:12px; padding:8px 10px;
      font-weight:600; cursor:pointer;
      transition: transform .08s ease, background .2s ease;
    }
    .btn:active{ transform: scale(.98); }
    .btn:hover{ background:#ffffff16; }

    #game{
      position:relative;
      width:100%;
      aspect-ratio:1/1;
      border-radius:22px;
      background: linear-gradient(180deg, #141824, #0f121b);
      border:1px solid #ffffff18;
      box-shadow: 0 12px 45px #00000066;
      overflow:hidden;
      touch-action:none;
    }

    /* faint target silhouette */
    .target{
      position:absolute; inset:0;
      opacity:.12; pointer-events:none;
      filter: drop-shadow(0 8px 18px #00000070);
      animation: breathe 2.6s ease-in-out infinite;
    }
    @keyframes breathe{
      0%,100%{ transform: scale(1); opacity:.10;}
      50%{ transform: scale(1.01); opacity:.15;}
    }

    .piece{
      position:absolute;
      width:50%; height:50%;
      cursor:grab;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      filter: drop-shadow(0 14px 20px #00000066);
      transition: transform .12s ease;
    }
    .piece:active{ cursor:grabbing; transform: scale(1.02); }
    .piece.idle{ animation: floaty 2.4s ease-in-out infinite; }
    @keyframes floaty{
      0%,100%{ transform: translateY(0px); }
      50%{ transform: translateY(-3px); }
    }

    .piece.locked{
      cursor:default;
      filter: drop-shadow(0 8px 14px #00000050);
    }
    .snap{
      animation: snap 380ms cubic-bezier(.2,1.2,.2,1);
    }
    @keyframes snap{
      0%{ transform: scale(1.08) rotate(-1deg); }
      60%{ transform: scale(.96) rotate(.6deg); }
      100%{ transform: scale(1) rotate(0); }
    }

    .toast{
      position:absolute; left:50%; top:16px; transform:translateX(-50%);
      background:#0b0d12cc; border:1px solid #ffffff1f;
      padding:8px 10px; border-radius:12px;
      color:#e7ebf5; font-weight:650; font-size:13px;
      opacity:0; pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      backdrop-filter: blur(10px);
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }
    .toast.hide{ opacity:0; transform:translateX(-50%) translateY(-6px); }

    /* completion overlay */
    .win{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(500px 400px at 50% 45%, #0b0d12cc 0%, #0b0d12f0 70%, #0b0d12ff 100%);
      opacity:0; pointer-events:none;
      transition: opacity .25s ease;
    }
    .win.show{ opacity:1; pointer-events:auto; }
    .win .card{
      width:min(86%, 360px);
      background:#151a25;
      border:1px solid #ffffff1f;
      border-radius:18px;
      padding:16px 14px;
      text-align:center;
      box-shadow: 0 18px 60px #00000080;
      transform: translateY(8px) scale(.98);
      animation: pop 420ms cubic-bezier(.2,1.3,.2,1) forwards;
    }
    @keyframes pop{
      to{ transform: translateY(0) scale(1); }
    }
    .win h2{ margin:0 0 6px; font-size:22px; }
    .win p{ margin:0 0 12px; color:#cdd5e6; }

    /* confetti canvas */
    #confetti{
      position:fixed; inset:0;
      pointer-events:none;
    }

    /* small screens: tighter HUD */
    @media (max-width:420px){
      .value{ font-size:16px; }
      .hud{ padding:9px 10px; }
      .hud .right{ gap:10px; }
      .btn{ padding:7px 9px; }
    }
  </style>
</head>
<body>
<canvas id="confetti"></canvas>

<div class="wrap">
  <div class="hud">
    <div class="left">
      <div class="stat">
        <div class="label">Timer</div>
        <div class="value" id="time">00:00</div>
      </div>
      <div class="stat">
        <div class="label">Score</div>
        <div class="value" id="score">10000</div>
      </div>
      <div class="stat">
        <div class="label">Moves</div>
        <div class="value" id="moves">0</div>
      </div>
    </div>
    <div class="right">
      <button class="btn" id="shuffle">Shuffle</button>
      <button class="btn" id="reset">Reset</button>
    </div>
  </div>

  <div id="game">
    <div class="toast" id="toast">Klikt vast!</div>

    <!-- faint full silhouette (same art + jigsaw outline) -->
    <svg class="target" viewBox="0 0 400 400" aria-hidden="true">
      <defs>
        <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
          <feGaussianBlur stdDeviation="1.2" />
        </filter>
      </defs>

      <!-- simple background art hint -->
      <rect x="0" y="0" width="400" height="400" fill="#ffffff" opacity="0.05" rx="18" />
      <text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
            font-size="260" font-weight="800" fill="#ffffff" opacity="0.35" filter="url(#soft)">34</text>

      <!-- outer outline -->
      <rect x="18" y="18" width="364" height="364" rx="18" ry="18" fill="none" stroke="#ffffff" opacity="0.25" stroke-width="3"/>
    </svg>

    <div id="win" class="win" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="card">
        <h2>Nice üòé</h2>
        <p>Je hebt de 34 compleet gemaakt!</p>
        <div class="stat" style="margin:10px 0 14px;">
          <div class="label">Eindscore</div>
          <div class="value" id="finalScore">0</div>
          <div class="label" style="margin-top:6px;">Tijd ‚Ä¢ Moves</div>
          <div class="value" style="font-size:16px; font-weight:650;" id="finalMeta">00:00 ‚Ä¢ 0</div>
        </div>
        <button class="btn" id="playAgain" style="width:100%;">Nog een keer</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const game = document.getElementById("game");
  const toast = document.getElementById("toast");
  const timeEl = document.getElementById("time");
  const scoreEl = document.getElementById("score");
  const movesEl = document.getElementById("moves");
  const winEl = document.getElementById("win");
  const finalScoreEl = document.getElementById("finalScore");
  const finalMetaEl = document.getElementById("finalMeta");

  const btnShuffle = document.getElementById("shuffle");
  const btnReset = document.getElementById("reset");
  const btnPlayAgain = document.getElementById("playAgain");

  // --- Timer + score ---
  let timerId = null;
  let startTime = null;
  let elapsedMs = 0;
  let started = false;
  let moves = 0;
  let placed = 0;
  const BASE_SCORE = 10000;

  function fmtTime(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function computeScore(ms, moves){
    // simple scoring: time + moves penalty
    const seconds = Math.floor(ms/1000);
    const score = Math.max(0, BASE_SCORE - seconds*20 - moves*50);
    return score;
  }

  function updateHUD(){
    timeEl.textContent = fmtTime(elapsedMs);
    scoreEl.textContent = computeScore(elapsedMs, moves);
    movesEl.textContent = moves;
  }

  function tick(){
    elapsedMs = Date.now() - startTime;
    updateHUD();
  }

  function startTimerIfNeeded(){
    if(started) return;
    started = true;
    startTime = Date.now() - elapsedMs;
    timerId = setInterval(tick, 100);
  }

  function stopTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null;
  }

  // --- Jigsaw paths (in 200x200 piece space, with a little margin for tabs) ---
  // We render each piece in a 220x220 viewBox and then scale to fit 50% x 50%.
  const TAB = 26;     // size of tab "bulge"
  const MID = 100;    // mid of the edge
  const R = 18;       // outer corner rounding
  const S = 200;      // base piece size (without extra margin)

  // helper to build an edge with optional tab out/in
  // side: "top","right","bottom","left"
  // kind: 0 = flat, 1 = tab out, -1 = tab in
  function edgePath(side, kind){
    // We‚Äôll draw a rounded-rect-ish outline with a single tab centered on internal edges.
    // Coordinate system: 0..200, we later add padding in SVG via viewBox.
    const k = kind; // -1,0,1
    const t = TAB * k;

    if(side === "top"){
      if(k === 0) return `L ${S-R} 0 Q ${S} 0 ${S} ${R}`;
      return `L ${MID-38} 0
              Q ${MID-18} 0 ${MID-18} ${R/2}
              C ${MID-18} ${R/2+10} ${MID-18} ${R/2+10} ${MID-18} ${R/2+18}
              C ${MID-18} ${R/2+28} ${MID-18+t} ${R/2+28} ${MID-18+t} ${R/2+18}
              C ${MID-18+t} ${R/2+10} ${MID+18+t} ${R/2+10} ${MID+18+t} ${R/2+18}
              C ${MID+18+t} ${R/2+28} ${MID+18} ${R/2+28} ${MID+18} ${R/2+18}
              C ${MID+18} ${R/2+10} ${MID+18} ${R/2+10} ${MID+18} ${R/2}
              Q ${MID+18} 0 ${MID+38} 0
              L ${S-R} 0
              Q ${S} 0 ${S} ${R}`;
    }

    if(side === "right"){
      if(k === 0) return `L ${S} ${S-R} Q ${S} ${S} ${S-R} ${S}`;
      return `L ${S} ${MID-38}
              Q ${S} ${MID-18} ${S-R/2} ${MID-18}
              C ${S-R/2-10} ${MID-18} ${S-R/2-10} ${MID-18} ${S-R/2-18} ${MID-18}
              C ${S-R/2-28} ${MID-18} ${S-R/2-28} ${MID-18+t} ${S-R/2-18} ${MID-18+t}
              C ${S-R/2-10} ${MID-18+t} ${S-R/2-10} ${MID+18+t} ${S-R/2-18} ${MID+18+t}
              C ${S-R/2-28} ${MID+18+t} ${S-R/2-28} ${MID+18} ${S-R/2-18} ${MID+18}
              C ${S-R/2-10} ${MID+18} ${S-R/2-10} ${MID+18} ${S-R/2} ${MID+18}
              Q ${S} ${MID+18} ${S} ${MID+38}
              L ${S} ${S-R}
              Q ${S} ${S} ${S-R} ${S}`;
    }

    if(side === "bottom"){
      if(k === 0) return `L ${R} ${S} Q 0 ${S} 0 ${S-R}`;
      return `L ${MID+38} ${S}
              Q ${MID+18} ${S} ${MID+18} ${S-R/2}
              C ${MID+18} ${S-R/2-10} ${MID+18} ${S-R/2-10} ${MID+18} ${S-R/2-18}
              C ${MID+18} ${S-R/2-28} ${MID+18-t} ${S-R/2-28} ${MID+18-t} ${S-R/2-18}
              C ${MID+18-t} ${S-R/2-10} ${MID-18-t} ${S-R/2-10} ${MID-18-t} ${S-R/2-18}
              C ${MID-18-t} ${S-R/2-28} ${MID-18} ${S-R/2-28} ${MID-18} ${S-R/2-18}
              C ${MID-18} ${S-R/2-10} ${MID-18} ${S-R/2-10} ${MID-18} ${S-R/2}
              Q ${MID-18} ${S} ${MID-38} ${S}
              L ${R} ${S}
              Q 0 ${S} 0 ${S-R}`;
    }

    // left
    if(k === 0) return `L 0 ${R} Q 0 0 ${R} 0`;
    return `L 0 ${MID+38}
            Q 0 ${MID+18} ${R/2} ${MID+18}
            C ${R/2+10} ${MID+18} ${R/2+10} ${MID+18} ${R/2+18} ${MID+18}
            C ${R/2+28} ${MID+18} ${R/2+28} ${MID+18-t} ${R/2+18} ${MID+18-t}
            C ${R/2+10} ${MID+18-t} ${R/2+10} ${MID-18-t} ${R/2+18} ${MID-18-t}
            C ${R/2+28} ${MID-18-t} ${R/2+28} ${MID-18} ${R/2+18} ${MID-18}
            C ${R/2+10} ${MID-18} ${R/2+10} ${MID-18} ${R/2} ${MID-18}
            Q 0 ${MID-18} 0 ${MID-38}
            L 0 ${R}
            Q 0 0 ${R} 0`;
  }

  // Piece definitions: each is a quadrant with complementary inner edges.
  // order: 0=TL,1=TR,2=BL,3=BR
  // edges: top,right,bottom,left kinds. Outer edges are flat(0). Inner edges are tab out/in.
  // We choose: vertical inner boundary: TL has tab OUT on right, TR has tab IN on left.
  // horizontal inner boundary: TL has tab IN on bottom, BL has tab OUT on top.
  const piecesDef = [
    { id:0, name:"TL", edges:{ top:0, right: 1, bottom:-1, left:0 }, off:{x:0,   y:0  } },
    { id:1, name:"TR", edges:{ top:0, right:0, bottom: 1, left:-1 }, off:{x:200, y:0  } },
    { id:2, name:"BL", edges:{ top:1, right:-1, bottom:0, left:0 }, off:{x:0,   y:200} },
    { id:3, name:"BR", edges:{ top:-1, right:0, bottom:0, left: 1 }, off:{x:200, y:200} },
  ];

  function buildPiecePath(edges){
    // Start at top-left corner with rounding
    let d = `M ${R} 0
             L ${S-R} 0
             Q ${S} 0 ${S} ${R}`;
    // right edge
    d += ` ${edgePath("right", edges.right)}`;
    // bottom edge
    d += ` ${edgePath("bottom", edges.bottom)}`;
    // left edge
    d += ` ${edgePath("left", edges.left)}`;
    d += ` Z`;
    // But we already began with top. Replace top segment with proper top edge including tab if needed:
    // Easiest: rebuild from scratch per edge in order.
    d = `M ${R} 0`;
    d += ` ${edgePath("top", edges.top)}`;
    d += ` ${edgePath("right", edges.right)}`;
    d += ` ${edgePath("bottom", edges.bottom)}`;
    d += ` ${edgePath("left", edges.left)}`;
    d += ` Z`;
    return d.replace(/\s+/g," ").trim();
  }

  function artSVG(){
    // the full 400x400 art, drawn inside each piece and shifted via transform
    return `
      <svg viewBox="0 0 400 400" width="400" height="400" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="glow" x="-30%" y="-30%" width="160%" height="160%">
            <feGaussianBlur stdDeviation="2.2" result="b"/>
            <feMerge>
              <feMergeNode in="b"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#ffffff"/>
            <stop offset="1" stop-color="#dbe6ff"/>
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="400" height="400" rx="18" fill="none"/>
        <text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
              font-size="260" font-weight="850" fill="url(#g)" filter="url(#glow)">34</text>
      </svg>
    `;
  }

  function createPiece(def){
    const el = document.createElement("div");
    el.className = "piece idle";
    el.dataset.id = def.id;
    el.dataset.locked = "0";

    const pathD = buildPiecePath(def.edges);

    // SVG inside piece: clip to jigsaw path, draw full art shifted to show correct quadrant
    const svg = `
      <svg viewBox="-10 -10 220 220" xmlns="http://www.w3.org/2000/svg" aria-label="puzzelstuk">
        <defs>
          <clipPath id="clip-${def.id}">
            <path d="${pathD}"></path>
          </clipPath>
        </defs>

        <!-- clipped art -->
        <g clip-path="url(#clip-${def.id})">
          <rect x="-10" y="-10" width="220" height="220" fill="#ffffff08"></rect>
          <g transform="translate(${-def.off.x} ${-def.off.y})">
            ${artSVG()}
          </g>
        </g>

        <!-- outline -->
        <path d="${pathD}" fill="transparent" stroke="${getComputedStyle(document.documentElement).getPropertyValue('--stroke') || '#fff'}"
              stroke-width="3" stroke-linejoin="round"/>
      </svg>
    `;
    el.innerHTML = svg;

    // Random starting position within bounds
    randomizePiecePosition(el);

    // drag logic
    enableDrag(el, def);

    game.appendChild(el);
    return el;
  }

  function gameRect(){ return game.getBoundingClientRect(); }

  function randomizePiecePosition(el){
    const r = gameRect();
    // keep pieces within game; spawn a bit away from center
    const pad = 12;
    const w = r.width * 0.5;
    const h = r.height * 0.5;

    const x = Math.random() * (r.width - w - pad*2) + pad;
    const y = Math.random() * (r.height - h - pad*2) + pad;

    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function correctPosPx(def){
    const r = gameRect();
    const x = (def.off.x / 400) * r.width;
    const y = (def.off.y / 400) * r.height;
    return {x, y};
  }

  function bringToFront(el){
    el.style.zIndex = String(1000 + Date.now()%1000);
  }

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.remove("hide");
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => {
      toast.classList.add("hide");
      toast.classList.remove("show");
    }, 650);
  }

  function enableDrag(el, def){
    let startX=0, startY=0, offX=0, offY=0, dragging=false;

    el.addEventListener("pointerdown", (e) => {
      if(el.dataset.locked === "1") return;

      startTimerIfNeeded();
      dragging = true;
      el.classList.remove("idle");
      bringToFront(el);
      el.setPointerCapture(e.pointerId);

      startX = e.clientX;
      startY = e.clientY;

      const left = parseFloat(el.style.left);
      const top  = parseFloat(el.style.top);
      offX = startX - left;
      offY = startY - top;
    });

    el.addEventListener("pointermove", (e) => {
      if(!dragging || el.dataset.locked === "1") return;
      const r = gameRect();
      const w = r.width * 0.5;
      const h = r.height * 0.5;

      let x = e.clientX - offX;
      let y = e.clientY - offY;

      // clamp inside game
      x = Math.max(-w*0.15, Math.min(r.width - w*0.85, x));
      y = Math.max(-h*0.15, Math.min(r.height - h*0.85, y));

      el.style.left = `${x}px`;
      el.style.top  = `${y}px`;
    });

    el.addEventListener("pointerup", () => {
      if(!dragging) return;
      dragging = false;

      // count a move when user releases after dragging
      moves++;
      updateHUD();

      // snap check
      const target = correctPosPx(def);
      const x = parseFloat(el.style.left);
      const y = parseFloat(el.style.top);

      const snapDist = Math.max(18, gameRect().width * 0.05); // responsive snap threshold
      if(Math.abs(x - target.x) < snapDist && Math.abs(y - target.y) < snapDist){
        el.style.left = `${target.x}px`;
        el.style.top  = `${target.y}px`;
        el.dataset.locked = "1";
        el.classList.add("locked","snap");
        setTimeout(()=>el.classList.remove("snap"), 450);
        showToast("Klikt vast!");
        placed++;
        if(placed === 4) onWin();
      } else {
        // idle animation returns
        el.classList.add("idle");
      }
    });
  }

  // --- Confetti ---
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRunning = false;

  function resizeConfetti(){
    confettiCanvas.width = window.innerWidth * devicePixelRatio;
    confettiCanvas.height = window.innerHeight * devicePixelRatio;
    confettiCanvas.style.width = window.innerWidth + "px";
    confettiCanvas.style.height = window.innerHeight + "px";
  }
  window.addEventListener("resize", () => {
    resizeConfetti();
    // also resnap locked pieces on resize to keep them aligned
    resnapLockedPieces();
  });
  resizeConfetti();

  function launchConfetti(){
    confetti = [];
    const W = confettiCanvas.width, H = confettiCanvas.height;
    const N = 240;

    for(let i=0;i<N;i++){
      confetti.push({
        x: Math.random()*W,
        y: -Math.random()*H*0.2,
        vx: (Math.random()-0.5) * 2.8 * devicePixelRatio,
        vy: (Math.random()*2.2 + 2.4) * devicePixelRatio,
        r: (Math.random()*6 + 4) * devicePixelRatio,
        a: Math.random()*Math.PI*2,
        va: (Math.random()-0.5)*0.2,
        life: 0,
        ttl: 220 + Math.random()*90,
        // no fixed colors required ‚Äî but confetti needs visible variety; we‚Äôll derive from HSL random
        h: Math.random()*360
      });
    }

    confettiRunning = true;
    requestAnimationFrame(confettiTick);
  }

  function confettiTick(){
    if(!confettiRunning) return;

    const W = confettiCanvas.width, H = confettiCanvas.height;
    ctx.clearRect(0,0,W,H);

    let alive = 0;
    for(const p of confetti){
      p.life++;
      if(p.life > p.ttl) continue;
      alive++;

      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02 * devicePixelRatio; // gravity
      p.a += p.va;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);
      ctx.globalAlpha = Math.max(0, 1 - (p.life / p.ttl));
      ctx.fillStyle = `hsl(${p.h} 90% 60%)`;
      ctx.fillRect(-p.r, -p.r*0.45, p.r*2, p.r*0.9);
      ctx.restore();
    }

    if(alive > 0) requestAnimationFrame(confettiTick);
    else { confettiRunning = false; ctx.clearRect(0,0,W,H); }
  }

  // --- Setup game ---
  let pieceEls = [];

  function clearPieces(){
    for(const el of pieceEls) el.remove();
    pieceEls = [];
  }

  function setup(){
    stopTimer();
    started = false;
    elapsedMs = 0;
    moves = 0;
    placed = 0;
    updateHUD();

    winEl.classList.remove("show");
    winEl.setAttribute("aria-hidden","true");

    clearPieces();
    // create pieces
    for(const def of piecesDef){
      pieceEls.push(createPiece(def));
    }
    // small entrance animation
    pieceEls.forEach((el,i)=>{
      el.style.transform = "scale(.98)";
      setTimeout(()=>{ el.style.transform=""; }, 60+i*45);
    });
  }

  function resnapLockedPieces(){
    // keep locked pieces aligned when viewport changes
    for(const el of pieceEls){
      if(el.dataset.locked !== "1") continue;
      const def = piecesDef[Number(el.dataset.id)];
      const target = correctPosPx(def);
      el.style.left = `${target.x}px`;
      el.style.top  = `${target.y}px`;
    }
  }

  function shuffle(){
    // only shuffle unlocked
    for(const el of pieceEls){
      if(el.dataset.locked === "1") continue;
      randomizePiecePosition(el);
      el.classList.add("idle");
    }
  }

  function onWin(){
    stopTimer();
    const score = computeScore(elapsedMs, moves);
    finalScoreEl.textContent = score;
    finalMetaEl.textContent = `${fmtTime(elapsedMs)} ‚Ä¢ ${moves}`;

    winEl.classList.add("show");
    winEl.setAttribute("aria-hidden","false");

    // confetti + little ‚Äúwin‚Äù pulse
    launchConfetti();
  }

  btnShuffle.addEventListener("click", shuffle);
  btnReset.addEventListener("click", setup);
  btnPlayAgain.addEventListener("click", setup);

  // Start
  setup();
})();
</script>
</body>
</html>

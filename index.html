<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>34 Puzzle</title>

<style>
  :root{
    --red:#B0002A;
    --bg:#070a12;
    --panel:#141a28;
  }

  body{
    margin:0;
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:center;
    font-family:Arial, sans-serif;
    overflow:hidden;
    color:white;
    background:var(--bg);
    position:relative;
  }

  /* ===== Logo achtergrond (NIET bewegen) ===== */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:0;

    background-image:url("logo.png");
    background-repeat:repeat;
    background-size:90px 90px;
    opacity:0.18;
  }

  body::after{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:0;

    background-image:url("logo.png");
    background-repeat:repeat;
    background-size:140px 140px;
    background-position:50px 30px;
    opacity:0.10;
  }

  /* ===== Layout: puzzel Ã©cht groot ===== */
  .wrapper{
    width:min(98vw, 1600px);
    height:98vh;                 /* bijna hele schermhoogte */
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    gap:10px;
    z-index:2;
  }

  .topbar{
    text-align:center;
    font-weight:800;
    font-size:20px;
    text-shadow: 0 2px 16px rgba(0,0,0,0.6);
  }

  /* game neemt vrijwel alle ruimte onder de timer */
  #gameSizer{
    flex:1;
    width:100%;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  #game{
    position:relative;

    /* maximaal groot, maar vierkant */
    width:min(98vw, 96vh, 1500px);
    height:min(98vw, 96vh, 1500px);

    background:var(--panel);
    border-radius:24px;
    overflow:hidden;
    touch-action:none;
    z-index:2;
    box-shadow: 0 16px 60px rgba(0,0,0,0.55);
  }

  .piece{
    position:absolute;
    width:50%;
    height:50%;
    cursor:grab;
    touch-action:none;
    user-select:none;
  }
  .piece.dragging{ cursor:grabbing; }
  .piece.locked{
    cursor:default;
    pointer-events:none;
  }

  #confetti{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:3;
  }
</style>
</head>

<body>

<canvas id="confetti"></canvas>

<div class="wrapper">
  <div class="topbar">
    Tijd: <span id="time">00:00</span>
  </div>

  <div id="gameSizer">
    <div id="game"></div>
  </div>
</div>

<script>
(() => {
  const RED = "#B0002A";
  const TAB = 30;
  const SIZE = 200;
  const R = 18;

  const defs = [
    { id:0, x:0,   y:0,   edges:[0,  1, -1,  0] },
    { id:1, x:200, y:0,   edges:[0,  0,  1, -1] },
    { id:2, x:0,   y:200, edges:[1, -1,  0,  0] },
    { id:3, x:200, y:200, edges:[-1, 0,  0,  1] }
  ];

  const game = document.getElementById("game");
  const timeEl = document.getElementById("time");

  let drag = null;
  let placed = 0;

  // timer
  let startTime = null;
  let timerInterval = null;

  function startTimer(){
    if(startTime) return;
    startTime = Date.now();
    timerInterval = setInterval(() => {
      const t = Date.now() - startTime;
      timeEl.textContent = new Date(t).toISOString().substr(14,5);
    }, 100);
  }

  function stopTimer(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  }

  function buildPath(top,right,bottom,left){
    function tab(out){
      const t = out ? TAB : -TAB;
      return `c0 -20 ${t} -20 ${t} 0 c0 20 ${-t} 20 ${-t} 0`;
    }

    let d = `M${R} 0 H${SIZE-R} Q${SIZE} 0 ${SIZE} ${R}`;
    if(right) d += tab(right > 0);
    d += `V${SIZE-R} Q${SIZE} ${SIZE} ${SIZE-R} ${SIZE}`;
    if(bottom) d += tab(bottom > 0);
    d += `H${R} Q0 ${SIZE} 0 ${SIZE-R}`;
    if(left) d += tab(left > 0);
    d += `V${R} Q0 0 ${R} 0 Z`;
    return d;
  }

  function gameRect(){ return game.getBoundingClientRect(); }

  function randomizePos(el){
    const r = gameRect();
    const w = r.width * 0.5;
    const h = r.height * 0.5;
    const pad = 12;

    const x = Math.random() * (r.width - w - pad*2) + pad;
    const y = Math.random() * (r.height - h - pad*2) + pad;

    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function createPiece(def){
    const el = document.createElement("div");
    el.className = "piece";

    const path = buildPath(...def.edges);

    el.innerHTML = `
      <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <clipPath id="clip${def.id}">
            <path d="${path}"></path>
          </clipPath>
        </defs>

        <g clip-path="url(#clip${def.id})">
          <text x="${200-def.x}" y="${260-def.y}"
                font-size="260" font-weight="900"
                fill="${RED}"
                text-anchor="middle"
                dominant-baseline="middle">34</text>
        </g>

        <path d="${path}" fill="none" stroke="white" stroke-width="3"
              stroke-linejoin="round"></path>
      </svg>
    `;

    randomizePos(el);

    el.addEventListener("pointerdown", (e) => {
      if(el.classList.contains("locked")) return;

      startTimer();
      el.classList.add("dragging");
      el.style.zIndex = String(1000 + (Date.now()%1000));

      drag = {
        el,
        def,
        offsetX: e.clientX - el.offsetLeft,
        offsetY: e.clientY - el.offsetTop,
        pointerId: e.pointerId
      };

      el.setPointerCapture(e.pointerId);
    });

    game.appendChild(el);
  }

  window.addEventListener("pointermove", (e) => {
    if(!drag) return;
    if(e.pointerId !== drag.pointerId) return;

    const r = gameRect();
    const w = r.width * 0.5;
    const h = r.height * 0.5;

    let x = e.clientX - drag.offsetX;
    let y = e.clientY - drag.offsetY;

    // keep mostly inside the square
    x = Math.max(-w*0.15, Math.min(r.width - w*0.85, x));
    y = Math.max(-h*0.15, Math.min(r.height - h*0.85, y));

    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
  });

  function endDrag(){
    if(!drag) return;

    const el = drag.el;
    const def = drag.def;

    el.classList.remove("dragging");

    const correctX = (def.x/400) * game.clientWidth;
    const correctY = (def.y/400) * game.clientHeight;

    const snapDist = Math.max(18, game.clientWidth * 0.06);

    if(Math.abs(el.offsetLeft - correctX) < snapDist &&
       Math.abs(el.offsetTop  - correctY) < snapDist){
      el.style.left = `${correctX}px`;
      el.style.top  = `${correctY}px`;
      el.classList.add("locked");
      placed++;

      if(placed === 4){
        stopTimer();
        launchConfetti();
      }
    }

    drag = null;
  }

  window.addEventListener("pointerup", endDrag);
  window.addEventListener("pointercancel", endDrag);
  window.addEventListener("lostpointercapture", endDrag);

  // confetti
  const canvas = document.getElementById("confetti");
  const ctx = canvas.getContext("2d");
  function resize(){
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
  }
  window.addEventListener("resize", resize);
  resize();

  let confetti = [];
  function launchConfetti(){
    confetti = [];
    const W = canvas.width, H = canvas.height;
    for(let i=0;i<240;i++){
      confetti.push({
        x: Math.random()*W,
        y: -Math.random()*H*0.2,
        vx: (Math.random()-0.5)*2.8*devicePixelRatio,
        vy: (Math.random()*2.2+2.6)*devicePixelRatio,
        r: (Math.random()*6+4)*devicePixelRatio,
        a: Math.random()*Math.PI*2,
        va: (Math.random()-0.5)*0.2,
        life: 0,
        ttl: 220 + Math.random()*90,
        h: Math.random()*360
      });
    }
    requestAnimationFrame(tickConfetti);
  }

  function tickConfetti(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    let alive = 0;

    for(const p of confetti){
      p.life++;
      if(p.life > p.ttl) continue;
      alive++;

      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02*devicePixelRatio;
      p.a += p.va;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);
      ctx.globalAlpha = Math.max(0, 1 - p.life/p.ttl);
      ctx.fillStyle = `hsl(${p.h} 90% 60%)`;
      ctx.fillRect(-p.r, -p.r*0.45, p.r*2, p.r*0.9);
      ctx.restore();
    }

    if(alive) requestAnimationFrame(tickConfetti);
  }

  // init
  defs.forEach(createPiece);
})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>34 Puzzle</title>
<style>
  body{
    margin:0;
    background:#0e111a;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:Arial, sans-serif;
    overflow:hidden;
    color:white;
  }
  .wrapper{ width:min(95vw,520px); }
  .topbar{
    text-align:center;
    margin-bottom:10px;
    font-weight:700;
    font-size:18px;
  }
  #game{
    position:relative;
    width:100%;
    aspect-ratio:1/1;
    background:#141a28;
    border-radius:20px;
    overflow:hidden;
    touch-action:none;
  }
  .piece{
    position:absolute;
    width:50%;
    height:50%;
    cursor:grab;
    touch-action:none;
    user-select:none;
    -webkit-user-select:none;
  }
  .piece.dragging{ cursor:grabbing; }
  .piece.locked{ cursor:default; }
  #confetti{
    position:fixed;
    inset:0;
    pointer-events:none;
  }
</style>
</head>
<body>

<canvas id="confetti"></canvas>

<div class="wrapper">
  <div class="topbar">Tijd: <span id="time">00:00</span></div>
  <div id="game"></div>
</div>

<script>
(() => {
  const RED = "#B0002A";

  // puzzelvorm params (in piece space 200x200)
  const TAB = 30;
  const SIZE = 200;
  const R = 18;

  const game = document.getElementById("game");
  const timeEl = document.getElementById("time");

  let placed = 0;

  // timer
  let startTime = null;
  let timerInterval = null;
  function startTimer(){
    if(startTime) return;
    startTime = Date.now();
    timerInterval = setInterval(() => {
      const t = Date.now() - startTime;
      timeEl.textContent = new Date(t).toISOString().substr(14,5);
    }, 100);
  }
  function stopTimer(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  }

  // path builder (simple jigsaw-ish tabs)
  function buildPath(top, right, bottom, left){
    function tab(out){
      const t = out ? TAB : -TAB;
      return `c0 -20 ${t} -20 ${t} 0 c0 20 ${-t} 20 ${-t} 0`;
    }

    let d = `M${R} 0 H${SIZE-R} Q${SIZE} 0 ${SIZE} ${R}`;

    if(right) d += tab(right > 0);
    d += `V${SIZE-R} Q${SIZE} ${SIZE} ${SIZE-R} ${SIZE}`;

    if(bottom) d += tab(bottom > 0);
    d += `H${R} Q0 ${SIZE} 0 ${SIZE-R}`;

    if(left) d += tab(left > 0);
    d += `V${R} Q0 0 ${R} 0 Z`;

    return d;
  }

  // piece definitions (complementary tabs)
  const defs = [
    { id:0, x:0,   y:0,   edges:[0,  1, -1,  0] }, // TL
    { id:1, x:200, y:0,   edges:[0,  0,  1, -1] }, // TR
    { id:2, x:0,   y:200, edges:[1, -1,  0,  0] }, // BL
    { id:3, x:200, y:200, edges:[-1, 0,  0,  1] }, // BR
  ];

  // drag state (global → altijd netjes loslaten)
  let drag = null; // {el, def, offsetX, offsetY, pointerId}

  function gameRect(){ return game.getBoundingClientRect(); }

  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  function randomizePos(el){
    const r = gameRect();
    const w = r.width * 0.5;
    const h = r.height * 0.5;
    const pad = 10;

    const x = Math.random() * (r.width - w - pad*2) + pad;
    const y = Math.random() * (r.height - h - pad*2) + pad;

    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function correctPosPx(def){
    const r = gameRect();
    return {
      x: (def.x / 400) * r.width,
      y: (def.y / 400) * r.height
    };
  }

  function createPiece(def){
    const el = document.createElement("div");
    el.className = "piece";
    el.dataset.locked = "0";

    const path = buildPath(...def.edges);

    el.innerHTML = `
      <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <clipPath id="clip${def.id}">
            <path d="${path}"></path>
          </clipPath>
        </defs>

        <g clip-path="url(#clip${def.id})">
          <text x="${200-def.x}" y="${260-def.y}"
                font-size="260" font-weight="900"
                fill="${RED}"
                text-anchor="middle"
                dominant-baseline="middle">34</text>
        </g>

        <path d="${path}" fill="none" stroke="white" stroke-width="3"
              stroke-linejoin="round"></path>
      </svg>
    `;

    randomizePos(el);

    el.addEventListener("pointerdown", (e) => {
      if(el.dataset.locked === "1") return;

      startTimer();
      el.classList.add("dragging");
      el.style.zIndex = String(1000 + Date.now()%1000);

      drag = {
        el, def,
        offsetX: e.clientX - el.offsetLeft,
        offsetY: e.clientY - el.offsetTop,
        pointerId: e.pointerId
      };

      // capture helps, but release is handled globally anyway
      el.setPointerCapture(e.pointerId);
    });

    game.appendChild(el);
  }

  // global move/up handlers (fix “niet kunnen loslaten”)
  window.addEventListener("pointermove", (e) => {
    if(!drag) return;
    if(e.pointerId !== drag.pointerId) return;

    const r = gameRect();
    const w = r.width * 0.5;
    const h = r.height * 0.5;

    let x = e.clientX - drag.offsetX;
    let y = e.clientY - drag.offsetY;

    // keep it roughly within game
    x = clamp(x, -w*0.15, r.width - w*0.85);
    y = clamp(y, -h*0.15, r.height - h*0.85);

    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
  });

  function endDrag(){
    if(!drag) return;

    const el = drag.el;
    const def = drag.def;

    el.classList.remove("dragging");

    const target = correctPosPx(def);
    const x = parseFloat(el.style.left);
    const y = parseFloat(el.style.top);

    const snapDist = Math.max(18, gameRect().width * 0.06);

    if(Math.abs(x - target.x) < snapDist && Math.abs(y - target.y) < snapDist){
      el.style.left = `${target.x}px`;
      el.style.top  = `${target.y}px`;
      el.dataset.locked = "1";
      el.classList.add("locked");
      el.style.pointerEvents = "none";
      placed++;
      if(placed === 4){
        stopTimer();
        launchConfetti();
      }
    }

    drag = null;
  }

  window.addEventListener("pointerup", endDrag);
  window.addEventListener("pointercancel", endDrag);
  window.addEventListener("lostpointercapture", endDrag);

  // confetti (same as before-ish)
  const canvas = document.getElementById("confetti");
  const ctx = canvas.getContext("2d");
  function resize(){
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
  }
  window.addEventListener("resize", resize);
  resize();

  let confetti = [];
  function launchConfetti(){
    confetti = [];
    const W = canvas.width, H = canvas.height;
    for(let i=0;i<220;i++){
      confetti.push({
        x: Math.random()*W,
        y: -Math.random()*H*0.2,
        vx: (Math.random()-0.5)*2.6*devicePixelRatio,
        vy: (Math.random()*2.2+2.6)*devicePixelRatio,
        r: (Math.random()*6+4)*devicePixelRatio,
        a: Math.random()*Math.PI*2,
        va: (Math.random()-0.5)*0.2,
        life: 0,
        ttl: 220 + Math.random()*80,
        h: Math.random()*360
      });
    }
    requestAnimationFrame(tickConfetti);
  }

  function tickConfetti(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    let alive = 0;

    for(const p of confetti){
      p.life++;
      if(p.life > p.ttl) continue;
      alive++;

      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.02*devicePixelRatio;
      p.a += p.va;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);
      ctx.globalAlpha = Math.max(0, 1 - p.life/p.ttl);
      ctx.fillStyle = `hsl(${p.h} 90% 60%)`;
      ctx.fillRect(-p.r, -p.r*0.45, p.r*2, p.r*0.9);
      ctx.restore();
    }
    if(alive) requestAnimationFrame(tickConfetti);
  }

  // init
  defs.forEach(createPiece);
})();
</script>
</body>
</html>
